---
layout: default
title: Monte Carlo Simulation
short: MC
permalink: /monte-carlo/
---

				<p>The Monte Carlo simulations can be found in the folder <code>mcEff</code>. There are three different simulations:

				<ul>
					<li><code>mc.c</code>: A generic simulation of particles generated in a circular source, arriving at a detector of circular cross section, placed at a distance <code>d</code> from the source. The thickness of the source is taken into account.</li>
					<li><code>mcScin.c</code>: Simulation of particles going through two scintillator detectors.</li>
					<li><code>mcScinIso.c</code>: Simulation for an isotropic angular distribution.</li>
				</ul>

				<h3>mc.c</h3>
				<p>The origin of coordinates is in the detector surface. The initial position of the particle in the source in cylindrical coordinates (&rho;, &phi;, z) is generated randomly. If the thickness of the source is <code>b</code>, its radius is <code>r</code> and the distance between detectors is <code>d</code>, the particle coordinates in the source (&rho;<sub>src</sub>, &phi;<sub>src</sub>, z<sub>src</sub>) are:</p>

				<p>
				&rho;<sub>src</sub> &isin; [0, r]<br />
				&phi;<sub>src</sub> &isin; [0, 2&pi;]<br />
				z<sub>src</sub> = b + d</p>

				<p>where <code>b</code> is generated randomly, since the particle can come from any deep. In cartesian coordinates:</p>
				<p>
		        x<sub>src</sub> = &rho;<sub>src</sub> cos(&phi;<sub>src</sub>)<br />
				y<sub>src</sub> = &rho;<sub>src</sub> sin(&phi;<sub>src</sub>)</p>


				<p>Next, the direction of the particle is generated. Only the particles inside the proper solid angle &Omega; will hit the detector.</p>

				<p>
				&theta; &isin; [0,  &pi;]<br />
				&phi;   &isin; [0, 2&pi;]</p>
				
				<p>Which in the code translates to:</p>
<pre><code class="language-c">/***************************************************
 * Photon coordinates at source
 * The origin is in the detector
 ***************************************************/
zSrc   = ( (double)rand()/RAND_MAX ) * b + d;
rSrc   = ( (double)rand()/RAND_MAX ) * r;
phiSrc = ( (double)rand()/RAND_MAX ) * 360 * pi/180.0;
xSrc   = rSrc * cos(phiSrc);
ySrc   = rSrc * sin(phiSrc);

/***************************************************
 * Photon exit direction (theta, phi)
 ***************************************************/
theta = ( (double)rand()/RAND_MAX ) *  90 * pi/180.0;
phi   = ( (double)rand()/RAND_MAX ) * 360 * pi/180.0;</code></pre>

				<p>Now that we have the initial position and exit direction of the particle from the source, we calculate at which position it arrives to the detector. First we calculate the projection <code>D</code> of the particle's trajectory over the detector surface:</p>

				<p>D = z<sub>src</sub> tan(&theta;)</p>
				
				<p>Defined like this, <code>D</code> will have the correct sign automatically. Now, from the projection <code>D</code> and the azimuthal angle &phi;, we can calculate the &rho; coordinate in the detector:</p>

				<p>
		        x<sub>det</sub> = x<sub>src</sub> + D cos(&phi;)<br />
				y<sub>det</sub> = y<sub>src</sub> + D sin(&phi;)<br />
				&rho;<sub>det</sub> = &radic; x<sub>det</sub><sup>2</sup> + y<sub>det</sub><sup>2</sup></p>

				<p>The position of the particle in the surface of the detector is given by (&rho;<sub>det</sub>, &phi;, 0). If <code>R</code> is the radius of the detector, the condition that a particle arrived at the detector is then &rho;<sub>det</sub> &lt; <code>R</code>. In our code:</p>

<pre><code class="language-c">/***************************************************
 * Photon coordinates at detector
 * D is the module of the vector projected in the detector
 ***************************************************/
D    = zSrc * tan(theta);
xDet = xSrc + D * cos(phi);
yDet = ySrc + D * sin(phi);
rDet = sqrt( xDet*xDet + yDet*yDet );

if (rDet &lt; R)
	Nin++;</code></pre>

				<p>The efficiency is then calculated as the ratio between the number of particles that reached the detector and the number of particles generated by the source.</p>

<pre><code class="language-c">gammaEff = (double)Nin / N;</code></pre>

				<h3>mcScin.c</h3>
				<p>For this calculation, the geometry of Appendix B in the <a href="https://github.com/{{ site.git_username }}/{{ site.git_repo }}/{{ site.lab-guide }}">lab-guide</a> is used. The scintillator detectors are placed facing each other and separated a certain distance <code>d</code>.</p>

				<p><img src="{{ "/img/app2.png" | prepend: site.baseurl }}" style="opacity:.5" width="810" height="569" alt="Scintillators set-up"></p>

				<p>The thickness of the detectors is not taken into account. The simulation acts as if the particle source were in the lower surface of the upper scintillator.</p>

				<p>The rest is very similar to the previous section. The (<code>x</code>, <code>y</code>) coordinates of the initial position of the particle in the upper detector are generated randomly, and then the projection over the lower detector is calculated as in the previous example and as explained in Appendix B of the <a href="https://github.com/{{ site.git_username }}/{{ site.git_repo }}/{{ site.lab-guide }}">lab-guide</a>.</p>

				<h3>mcScinIso.c</h3>
				<p>To simulate an isotropic angular distribution, we can use the same code of the previous section, if we just change the line:</p>

<pre><code class="language-c">cosine  = pow( (double)rand() / RAND_MAX, 1/4.0 );</code></pre>
				<p>for the line:</p>
<pre><code class="language-c">cosine  = 1 - 2 * ( (double)rand() / RAND_MAX );</code></pre>


